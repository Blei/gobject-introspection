<FUNCTION>
<NAME>g_type_info_new</NAME>
<RETURNS>GITypeInfo  *</RETURNS>
GIBaseInfo    *container,GTypelib     *typelib,guint32        offset
</FUNCTION>
<FUNCTION>
<NAME>g_info_new_full</NAME>
<RETURNS>GIBaseInfo  *</RETURNS>
GIInfoType     type,GIRepository  *repository,GIBaseInfo    *container,GTypelib      *typelib,guint32        offset
</FUNCTION>
<MACRO>
<NAME>G_TYPE_IREPOSITORY</NAME>
#define G_TYPE_IREPOSITORY      (g_irepository_get_type ())
</MACRO>
<MACRO>
<NAME>G_IREPOSITORY</NAME>
#define G_IREPOSITORY(obj)      (G_TYPE_CHECK_INSTANCE_CAST ((obj), G_TYPE_IREPOSITORY, GIRepository))
</MACRO>
<STRUCT>
<NAME>GIRepository</NAME>
</STRUCT>
<STRUCT>
<NAME>GIRepositoryClass</NAME>
</STRUCT>
<STRUCT>
<NAME>GIRepositoryPrivate</NAME>
</STRUCT>
<STRUCT>
<NAME>GIBaseInfo</NAME>
</STRUCT>
<STRUCT>
<NAME>GICallableInfo</NAME>
</STRUCT>
<STRUCT>
<NAME>GIFunctionInfo</NAME>
</STRUCT>
<STRUCT>
<NAME>GICallbackInfo</NAME>
</STRUCT>
<STRUCT>
<NAME>GIRegisteredTypeInfo</NAME>
</STRUCT>
<STRUCT>
<NAME>GIStructInfo</NAME>
</STRUCT>
<STRUCT>
<NAME>GIUnionInfo</NAME>
</STRUCT>
<STRUCT>
<NAME>GIEnumInfo</NAME>
</STRUCT>
<STRUCT>
<NAME>GIObjectInfo</NAME>
</STRUCT>
<STRUCT>
<NAME>GIInterfaceInfo</NAME>
</STRUCT>
<STRUCT>
<NAME>GIConstantInfo</NAME>
</STRUCT>
<STRUCT>
<NAME>GIValueInfo</NAME>
</STRUCT>
<STRUCT>
<NAME>GISignalInfo</NAME>
</STRUCT>
<STRUCT>
<NAME>GIVFuncInfo</NAME>
</STRUCT>
<STRUCT>
<NAME>GIPropertyInfo</NAME>
</STRUCT>
<STRUCT>
<NAME>GIFieldInfo</NAME>
</STRUCT>
<STRUCT>
<NAME>GIArgInfo</NAME>
</STRUCT>
<STRUCT>
<NAME>GITypeInfo</NAME>
</STRUCT>
<STRUCT>
<NAME>GIErrorDomainInfo</NAME>
</STRUCT>
<STRUCT>
<NAME>GIUnresolvedInfo</NAME>
</STRUCT>
<STRUCT>
<NAME>GTypelib</NAME>
</STRUCT>
<STRUCT>
<NAME>GIRepository</NAME>
struct _GIRepository 
{ 
  GObject parent; 

  /*< private >*/
  GIRepositoryPrivate *priv;
};
</STRUCT>
<STRUCT>
<NAME>GIRepositoryClass</NAME>
struct _GIRepositoryClass
{ 
  GObjectClass parent; 
};
</STRUCT>
<ENUM>
<NAME>GIRepositoryLoadFlags</NAME>
typedef enum
{
  G_IREPOSITORY_LOAD_FLAG_LAZY = 1 << 0
} GIRepositoryLoadFlags;
</ENUM>
<FUNCTION>
<NAME>g_irepository_get_type</NAME>
<RETURNS>GType         </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>g_irepository_get_default</NAME>
<RETURNS>GIRepository *</RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>g_irepository_prepend_search_path</NAME>
<RETURNS>void          </RETURNS>
const char *directory
</FUNCTION>
<FUNCTION>
<NAME>g_irepository_get_search_path</NAME>
<RETURNS>GSList *</RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>g_irepository_load_typelib</NAME>
<RETURNS>const char *</RETURNS>
GIRepository *repository,GTypelib     *typelib,GIRepositoryLoadFlags flags,GError      **error
</FUNCTION>
<FUNCTION>
<NAME>g_irepository_is_registered</NAME>
<RETURNS>gboolean      </RETURNS>
GIRepository *repository,const gchar  *namespace_,const gchar  *version
</FUNCTION>
<FUNCTION>
<NAME>g_irepository_find_by_name</NAME>
<RETURNS>GIBaseInfo *</RETURNS>
GIRepository *repository,const gchar  *namespace_,const gchar  *name
</FUNCTION>
<FUNCTION>
<NAME>g_irepository_require</NAME>
<RETURNS>GTypelib *</RETURNS>
GIRepository *repository,const gchar  *namespace_,const gchar  *version,GIRepositoryLoadFlags flags,GError      **error
</FUNCTION>
<FUNCTION>
<NAME>g_irepository_get_dependencies</NAME>
<RETURNS>gchar      **</RETURNS>
GIRepository *repository,const gchar  *namespace_
</FUNCTION>
<FUNCTION>
<NAME>g_irepository_get_loaded_namespaces</NAME>
<RETURNS>gchar      **</RETURNS>
GIRepository *repository
</FUNCTION>
<FUNCTION>
<NAME>g_irepository_find_by_gtype</NAME>
<RETURNS>GIBaseInfo *</RETURNS>
GIRepository *repository,GType         gtype
</FUNCTION>
<FUNCTION>
<NAME>g_irepository_get_n_infos</NAME>
<RETURNS>gint          </RETURNS>
GIRepository *repository,const gchar  *namespace_
</FUNCTION>
<FUNCTION>
<NAME>g_irepository_get_info</NAME>
<RETURNS>GIBaseInfo *</RETURNS>
GIRepository *repository,const gchar  *namespace_,gint          index
</FUNCTION>
<FUNCTION>
<NAME>g_irepository_get_typelib_path</NAME>
<RETURNS>const gchar *</RETURNS>
GIRepository *repository,const gchar  *namespace_
</FUNCTION>
<FUNCTION>
<NAME>g_irepository_get_shared_library</NAME>
<RETURNS>const gchar *</RETURNS>
GIRepository *repository,const gchar  *namespace_
</FUNCTION>
<FUNCTION>
<NAME>g_irepository_get_version</NAME>
<RETURNS>const gchar *</RETURNS>
GIRepository *repository,const gchar  *namespace_
</FUNCTION>
<FUNCTION>
<NAME>g_irepository_get_option_group</NAME>
<RETURNS>GOptionGroup *</RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>g_irepository_dump</NAME>
<RETURNS>gboolean       </RETURNS>
const char *arg, GError **error
</FUNCTION>
<FUNCTION>
<NAME>g_typelib_new_from_memory</NAME>
<RETURNS>GTypelib *</RETURNS>
guchar       *memory,gsize         len
</FUNCTION>
<FUNCTION>
<NAME>g_typelib_new_from_const_memory</NAME>
<RETURNS>GTypelib *</RETURNS>
const guchar *memory,gsize         len
</FUNCTION>
<FUNCTION>
<NAME>g_typelib_new_from_mapped_file</NAME>
<RETURNS>GTypelib *</RETURNS>
GMappedFile  *mfile
</FUNCTION>
<FUNCTION>
<NAME>g_typelib_free</NAME>
<RETURNS>void          </RETURNS>
GTypelib    *typelib
</FUNCTION>
<FUNCTION>
<NAME>g_typelib_symbol</NAME>
<RETURNS>gboolean      </RETURNS>
GTypelib    *typelib,const gchar *symbol_name,gpointer    *symbol
</FUNCTION>
<FUNCTION>
<NAME>g_typelib_get_namespace</NAME>
<RETURNS>const gchar *</RETURNS>
GTypelib    *typelib
</FUNCTION>
<ENUM>
<NAME>GIRepositoryError</NAME>
typedef enum
{
  G_IREPOSITORY_ERROR_TYPELIB_NOT_FOUND,
  G_IREPOSITORY_ERROR_NAMESPACE_MISMATCH,
  G_IREPOSITORY_ERROR_NAMESPACE_VERSION_CONFLICT,
  G_IREPOSITORY_ERROR_LIBRARY_NOT_FOUND
} GIRepositoryError;
</ENUM>
<MACRO>
<NAME>G_IREPOSITORY_ERROR</NAME>
#define G_IREPOSITORY_ERROR (g_irepository_error_quark ())
</MACRO>
<FUNCTION>
<NAME>g_irepository_error_quark</NAME>
<RETURNS>GQuark </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gi_cclosure_marshal_generic</NAME>
<RETURNS>void </RETURNS>
GClosure       *closure,GValue         *return_gvalue,guint           n_param_values,const GValue   *param_values,gpointer        invocation_hint,gpointer        marshal_data
</FUNCTION>
<ENUM>
<NAME>GIInfoType</NAME>
typedef enum 
{
  GI_INFO_TYPE_INVALID,
  GI_INFO_TYPE_FUNCTION,
  GI_INFO_TYPE_CALLBACK,
  GI_INFO_TYPE_STRUCT,
  GI_INFO_TYPE_BOXED,
  GI_INFO_TYPE_ENUM,
  GI_INFO_TYPE_FLAGS,
  GI_INFO_TYPE_OBJECT,
  GI_INFO_TYPE_INTERFACE,
  GI_INFO_TYPE_CONSTANT,
  GI_INFO_TYPE_ERROR_DOMAIN,
  GI_INFO_TYPE_UNION,
  GI_INFO_TYPE_VALUE,
  GI_INFO_TYPE_SIGNAL,
  GI_INFO_TYPE_VFUNC,
  GI_INFO_TYPE_PROPERTY,
  GI_INFO_TYPE_FIELD,
  GI_INFO_TYPE_ARG,
  GI_INFO_TYPE_TYPE,
  GI_INFO_TYPE_UNRESOLVED
} GIInfoType;
</ENUM>
<FUNCTION>
<NAME>g_base_info_ref</NAME>
<RETURNS>GIBaseInfo *</RETURNS>
GIBaseInfo   *info
</FUNCTION>
<FUNCTION>
<NAME>g_base_info_unref</NAME>
<RETURNS>void                   </RETURNS>
GIBaseInfo   *info
</FUNCTION>
<FUNCTION>
<NAME>g_base_info_get_type</NAME>
<RETURNS>GIInfoType             </RETURNS>
GIBaseInfo   *info
</FUNCTION>
<FUNCTION>
<NAME>g_base_info_get_name</NAME>
<RETURNS>const gchar *</RETURNS>
GIBaseInfo   *info
</FUNCTION>
<FUNCTION>
<NAME>g_base_info_get_namespace</NAME>
<RETURNS>const gchar *</RETURNS>
GIBaseInfo   *info
</FUNCTION>
<FUNCTION>
<NAME>g_base_info_is_deprecated</NAME>
<RETURNS>gboolean               </RETURNS>
GIBaseInfo   *info
</FUNCTION>
<FUNCTION>
<NAME>g_base_info_get_annotation</NAME>
<RETURNS>const gchar *</RETURNS>
GIBaseInfo   *info,const gchar  *name
</FUNCTION>
<FUNCTION>
<NAME>g_base_info_get_container</NAME>
<RETURNS>GIBaseInfo *</RETURNS>
GIBaseInfo   *info
</FUNCTION>
<FUNCTION>
<NAME>g_base_info_get_typelib</NAME>
<RETURNS>GTypelib *</RETURNS>
GIBaseInfo   *info
</FUNCTION>
<FUNCTION>
<NAME>g_info_new</NAME>
<RETURNS>GIBaseInfo *</RETURNS>
GIInfoType    type,GIBaseInfo   *container,GTypelib     *typelib,guint32       offset
</FUNCTION>
<ENUM>
<NAME>GIFunctionInfoFlags</NAME>
typedef enum
{
  GI_FUNCTION_IS_METHOD      = 1 << 0,
  GI_FUNCTION_IS_CONSTRUCTOR = 1 << 1,
  GI_FUNCTION_IS_GETTER      = 1 << 2,
  GI_FUNCTION_IS_SETTER      = 1 << 3,
  GI_FUNCTION_WRAPS_VFUNC    = 1 << 4,
  GI_FUNCTION_THROWS         = 1 << 5
} GIFunctionInfoFlags;
</ENUM>
<FUNCTION>
<NAME>g_function_info_get_symbol</NAME>
<RETURNS>const gchar *</RETURNS>
GIFunctionInfo *info
</FUNCTION>
<FUNCTION>
<NAME>g_function_info_get_flags</NAME>
<RETURNS>GIFunctionInfoFlags     </RETURNS>
GIFunctionInfo *info
</FUNCTION>
<FUNCTION>
<NAME>g_function_info_get_property</NAME>
<RETURNS>GIPropertyInfo *</RETURNS>
GIFunctionInfo *info
</FUNCTION>
<FUNCTION>
<NAME>g_function_info_get_vfunc</NAME>
<RETURNS>GIVFuncInfo *</RETURNS>
GIFunctionInfo *info
</FUNCTION>
<MACRO>
<NAME>G_INVOKE_ERROR</NAME>
#define G_INVOKE_ERROR (g_invoke_error_quark ())
</MACRO>
<FUNCTION>
<NAME>g_invoke_error_quark</NAME>
<RETURNS>GQuark </RETURNS>
void
</FUNCTION>
<ENUM>
<NAME>GInvokeError</NAME>
typedef enum
{
  G_INVOKE_ERROR_FAILED,
  G_INVOKE_ERROR_SYMBOL_NOT_FOUND,
  G_INVOKE_ERROR_ARGUMENT_MISMATCH
} GInvokeError;
</ENUM>
<FUNCTION>
<NAME>g_function_info_invoke</NAME>
<RETURNS>gboolean              </RETURNS>
GIFunctionInfo *info,const GArgument  *in_args,int               n_in_args,const GArgument  *out_args,int               n_out_args,GArgument        *return_value,GError          **error
</FUNCTION>
<ENUM>
<NAME>GITransfer</NAME>
typedef enum {
  GI_TRANSFER_NOTHING,
  GI_TRANSFER_CONTAINER,
  GI_TRANSFER_EVERYTHING
} GITransfer;
</ENUM>
<FUNCTION>
<NAME>g_callable_info_get_return_type</NAME>
<RETURNS>GITypeInfo *</RETURNS>
GICallableInfo *info
</FUNCTION>
<FUNCTION>
<NAME>g_callable_info_get_caller_owns</NAME>
<RETURNS>GITransfer             </RETURNS>
GICallableInfo *info
</FUNCTION>
<FUNCTION>
<NAME>g_callable_info_may_return_null</NAME>
<RETURNS>gboolean               </RETURNS>
GICallableInfo *info
</FUNCTION>
<FUNCTION>
<NAME>g_callable_info_get_n_args</NAME>
<RETURNS>gint                   </RETURNS>
GICallableInfo *info
</FUNCTION>
<FUNCTION>
<NAME>g_callable_info_get_arg</NAME>
<RETURNS>GIArgInfo *</RETURNS>
GICallableInfo *info,gint           n
</FUNCTION>
<ENUM>
<NAME>GIDirection</NAME>
typedef enum  {
  GI_DIRECTION_IN,
  GI_DIRECTION_OUT,
  GI_DIRECTION_INOUT
} GIDirection;
</ENUM>
<ENUM>
<NAME>GIScopeType</NAME>
typedef enum {
  GI_SCOPE_TYPE_INVALID,
  GI_SCOPE_TYPE_CALL,
  GI_SCOPE_TYPE_OBJECT,
  GI_SCOPE_TYPE_ASYNC,
  GI_SCOPE_TYPE_NOTIFIED
} GIScopeType;
</ENUM>
<FUNCTION>
<NAME>g_arg_info_get_direction</NAME>
<RETURNS>GIDirection            </RETURNS>
GIArgInfo *info
</FUNCTION>
<FUNCTION>
<NAME>g_arg_info_is_dipper</NAME>
<RETURNS>gboolean               </RETURNS>
GIArgInfo *info
</FUNCTION>
<FUNCTION>
<NAME>g_arg_info_is_return_value</NAME>
<RETURNS>gboolean               </RETURNS>
GIArgInfo *info
</FUNCTION>
<FUNCTION>
<NAME>g_arg_info_is_optional</NAME>
<RETURNS>gboolean               </RETURNS>
GIArgInfo *info
</FUNCTION>
<FUNCTION>
<NAME>g_arg_info_may_be_null</NAME>
<RETURNS>gboolean               </RETURNS>
GIArgInfo *info
</FUNCTION>
<FUNCTION>
<NAME>g_arg_info_get_ownership_transfer</NAME>
<RETURNS>GITransfer             </RETURNS>
GIArgInfo *info
</FUNCTION>
<FUNCTION>
<NAME>g_arg_info_get_scope</NAME>
<RETURNS>GIScopeType            </RETURNS>
GIArgInfo *info
</FUNCTION>
<FUNCTION>
<NAME>g_arg_info_get_closure</NAME>
<RETURNS>gint                   </RETURNS>
GIArgInfo *info
</FUNCTION>
<FUNCTION>
<NAME>g_arg_info_get_destroy</NAME>
<RETURNS>gint                   </RETURNS>
GIArgInfo *info
</FUNCTION>
<FUNCTION>
<NAME>g_arg_info_get_type</NAME>
<RETURNS>GITypeInfo *</RETURNS>
GIArgInfo *info
</FUNCTION>
<ENUM>
<NAME>GITypeTag</NAME>
typedef enum {
  /* Basic types */
  GI_TYPE_TAG_VOID      =  0,
  GI_TYPE_TAG_BOOLEAN   =  1,
  GI_TYPE_TAG_INT8      =  2,
  GI_TYPE_TAG_UINT8     =  3,
  GI_TYPE_TAG_INT16     =  4,
  GI_TYPE_TAG_UINT16    =  5,  
  GI_TYPE_TAG_INT32     =  6,
  GI_TYPE_TAG_UINT32    =  7,
  GI_TYPE_TAG_INT64     =  8,
  GI_TYPE_TAG_UINT64    =  9,
  GI_TYPE_TAG_INT       = 10,
  GI_TYPE_TAG_UINT      = 11,
  GI_TYPE_TAG_LONG      = 12,
  GI_TYPE_TAG_ULONG     = 13,
  GI_TYPE_TAG_SSIZE     = 14,
  GI_TYPE_TAG_SIZE      = 15,
  GI_TYPE_TAG_FLOAT     = 16,
  GI_TYPE_TAG_DOUBLE    = 17,
  GI_TYPE_TAG_TIME_T    = 18,
  GI_TYPE_TAG_GTYPE     = 19,
  GI_TYPE_TAG_UTF8      = 20,
  GI_TYPE_TAG_FILENAME  = 21,
  /* Non-basic types */
  GI_TYPE_TAG_ARRAY     = 22,
  GI_TYPE_TAG_INTERFACE = 23,
  GI_TYPE_TAG_GLIST     = 24,
  GI_TYPE_TAG_GSLIST    = 25,
  GI_TYPE_TAG_GHASH     = 26,
  GI_TYPE_TAG_ERROR     = 27
  /* Note - there is only room currently for 32 tags.
   * See docs/typelib-format.txt SimpleTypeBlob definition */
} GITypeTag;
</ENUM>
<MACRO>
<NAME>G_TYPE_TAG_IS_BASIC</NAME>
#define G_TYPE_TAG_IS_BASIC(tag) (tag < GI_TYPE_TAG_ARRAY)
</MACRO>
<FUNCTION>
<NAME>g_type_tag_to_string</NAME>
<RETURNS>const gchar*</RETURNS>
GITypeTag   type
</FUNCTION>
<FUNCTION>
<NAME>g_type_info_is_pointer</NAME>
<RETURNS>gboolean               </RETURNS>
GITypeInfo *info
</FUNCTION>
<FUNCTION>
<NAME>g_type_info_get_tag</NAME>
<RETURNS>GITypeTag              </RETURNS>
GITypeInfo *info
</FUNCTION>
<FUNCTION>
<NAME>g_type_info_get_param_type</NAME>
<RETURNS>GITypeInfo *</RETURNS>
GITypeInfo *info,gint       n
</FUNCTION>
<FUNCTION>
<NAME>g_type_info_get_interface</NAME>
<RETURNS>GIBaseInfo *</RETURNS>
GITypeInfo *info
</FUNCTION>
<FUNCTION>
<NAME>g_type_info_get_array_length</NAME>
<RETURNS>gint                   </RETURNS>
GITypeInfo *info
</FUNCTION>
<FUNCTION>
<NAME>g_type_info_get_array_fixed_size</NAME>
<RETURNS>gint                   </RETURNS>
GITypeInfo *info
</FUNCTION>
<FUNCTION>
<NAME>g_type_info_is_zero_terminated</NAME>
<RETURNS>gboolean               </RETURNS>
GITypeInfo *info
</FUNCTION>
<FUNCTION>
<NAME>g_type_info_get_n_error_domains</NAME>
<RETURNS>gint                   </RETURNS>
GITypeInfo *info
</FUNCTION>
<FUNCTION>
<NAME>g_type_info_get_error_domain</NAME>
<RETURNS>GIErrorDomainInfo     *</RETURNS>
GITypeInfo *info,gint       n
</FUNCTION>
<FUNCTION>
<NAME>g_error_domain_info_get_quark</NAME>
<RETURNS>const gchar *</RETURNS>
GIErrorDomainInfo *info
</FUNCTION>
<FUNCTION>
<NAME>g_error_domain_info_get_codes</NAME>
<RETURNS>GIInterfaceInfo *</RETURNS>
GIErrorDomainInfo *info
</FUNCTION>
<FUNCTION>
<NAME>g_value_info_get_value</NAME>
<RETURNS>glong                  </RETURNS>
GIValueInfo *info
</FUNCTION>
<ENUM>
<NAME>GIFieldInfoFlags</NAME>
typedef enum
{
  GI_FIELD_IS_READABLE = 1 << 0,
  GI_FIELD_IS_WRITABLE = 1 << 1
} GIFieldInfoFlags;
</ENUM>
<FUNCTION>
<NAME>g_field_info_get_flags</NAME>
<RETURNS>GIFieldInfoFlags       </RETURNS>
GIFieldInfo *info
</FUNCTION>
<FUNCTION>
<NAME>g_field_info_get_size</NAME>
<RETURNS>gint                   </RETURNS>
GIFieldInfo *info
</FUNCTION>
<FUNCTION>
<NAME>g_field_info_get_offset</NAME>
<RETURNS>gint                   </RETURNS>
GIFieldInfo *info
</FUNCTION>
<FUNCTION>
<NAME>g_field_info_get_type</NAME>
<RETURNS>GITypeInfo *</RETURNS>
GIFieldInfo *info
</FUNCTION>
<FUNCTION>
<NAME>g_field_info_get_field</NAME>
<RETURNS>gboolean </RETURNS>
GIFieldInfo     *field_info,gpointer         mem,GArgument       *value
</FUNCTION>
<FUNCTION>
<NAME>g_field_info_set_field</NAME>
<RETURNS>gboolean </RETURNS>
GIFieldInfo     *field_info,gpointer         mem,const GArgument *value
</FUNCTION>
<FUNCTION>
<NAME>g_union_info_get_n_fields</NAME>
<RETURNS>gint                   </RETURNS>
GIUnionInfo *info
</FUNCTION>
<FUNCTION>
<NAME>g_union_info_get_field</NAME>
<RETURNS>GIFieldInfo *</RETURNS>
GIUnionInfo *info,gint         n
</FUNCTION>
<FUNCTION>
<NAME>g_union_info_get_n_methods</NAME>
<RETURNS>gint                   </RETURNS>
GIUnionInfo *info
</FUNCTION>
<FUNCTION>
<NAME>g_union_info_get_method</NAME>
<RETURNS>GIFunctionInfo *</RETURNS>
GIUnionInfo *info,gint         n
</FUNCTION>
<FUNCTION>
<NAME>g_union_info_is_discriminated</NAME>
<RETURNS>gboolean               </RETURNS>
GIUnionInfo *info
</FUNCTION>
<FUNCTION>
<NAME>g_union_info_get_discriminator_offset</NAME>
<RETURNS>gint                   </RETURNS>
GIUnionInfo *info
</FUNCTION>
<FUNCTION>
<NAME>g_union_info_get_discriminator_type</NAME>
<RETURNS>GITypeInfo *</RETURNS>
GIUnionInfo *info
</FUNCTION>
<FUNCTION>
<NAME>g_union_info_get_discriminator</NAME>
<RETURNS>GIConstantInfo *</RETURNS>
GIUnionInfo *info,gint         n
</FUNCTION>
<FUNCTION>
<NAME>g_union_info_find_method</NAME>
<RETURNS>GIFunctionInfo *</RETURNS>
GIUnionInfo *info,const gchar *name
</FUNCTION>
<FUNCTION>
<NAME>g_union_info_get_size</NAME>
<RETURNS>gsize                  </RETURNS>
GIUnionInfo *info
</FUNCTION>
<FUNCTION>
<NAME>g_union_info_get_alignment</NAME>
<RETURNS>gsize                  </RETURNS>
GIUnionInfo *info
</FUNCTION>
<FUNCTION>
<NAME>g_struct_info_get_n_fields</NAME>
<RETURNS>gint                   </RETURNS>
GIStructInfo *info
</FUNCTION>
<FUNCTION>
<NAME>g_struct_info_get_field</NAME>
<RETURNS>GIFieldInfo *</RETURNS>
GIStructInfo *info,gint         n
</FUNCTION>
<FUNCTION>
<NAME>g_struct_info_get_n_methods</NAME>
<RETURNS>gint                   </RETURNS>
GIStructInfo *info
</FUNCTION>
<FUNCTION>
<NAME>g_struct_info_get_method</NAME>
<RETURNS>GIFunctionInfo *</RETURNS>
GIStructInfo *info,gint         n
</FUNCTION>
<FUNCTION>
<NAME>g_struct_info_find_method</NAME>
<RETURNS>GIFunctionInfo *</RETURNS>
GIStructInfo *info,const gchar *name
</FUNCTION>
<FUNCTION>
<NAME>g_struct_info_get_size</NAME>
<RETURNS>gsize                  </RETURNS>
GIStructInfo *info
</FUNCTION>
<FUNCTION>
<NAME>g_struct_info_get_alignment</NAME>
<RETURNS>gsize                  </RETURNS>
GIStructInfo *info
</FUNCTION>
<FUNCTION>
<NAME>g_struct_info_is_class_struct</NAME>
<RETURNS>gboolean               </RETURNS>
GIStructInfo *info
</FUNCTION>
<FUNCTION>
<NAME>g_registered_type_info_get_type_name</NAME>
<RETURNS>const gchar *</RETURNS>
GIRegisteredTypeInfo *info
</FUNCTION>
<FUNCTION>
<NAME>g_registered_type_info_get_type_init</NAME>
<RETURNS>const gchar *</RETURNS>
GIRegisteredTypeInfo *info
</FUNCTION>
<FUNCTION>
<NAME>g_registered_type_info_get_g_type</NAME>
<RETURNS>GType                  </RETURNS>
GIRegisteredTypeInfo *info
</FUNCTION>
<FUNCTION>
<NAME>g_enum_info_get_n_values</NAME>
<RETURNS>gint                   </RETURNS>
GIEnumInfo      *info
</FUNCTION>
<FUNCTION>
<NAME>g_enum_info_get_value</NAME>
<RETURNS>GIValueInfo  *</RETURNS>
GIEnumInfo      *info,gint            n
</FUNCTION>
<FUNCTION>
<NAME>g_enum_info_get_storage_type</NAME>
<RETURNS>GITypeTag              </RETURNS>
GIEnumInfo      *info
</FUNCTION>
<FUNCTION>
<NAME>g_object_info_get_type_name</NAME>
<RETURNS>const gchar *</RETURNS>
GIObjectInfo    *info
</FUNCTION>
<FUNCTION>
<NAME>g_object_info_get_type_init</NAME>
<RETURNS>const gchar *</RETURNS>
GIObjectInfo    *info
</FUNCTION>
<FUNCTION>
<NAME>g_object_info_get_abstract</NAME>
<RETURNS>gboolean               </RETURNS>
GIObjectInfo    *info
</FUNCTION>
<FUNCTION>
<NAME>g_object_info_get_parent</NAME>
<RETURNS>GIObjectInfo *</RETURNS>
GIObjectInfo    *info
</FUNCTION>
<FUNCTION>
<NAME>g_object_info_get_n_interfaces</NAME>
<RETURNS>gint                   </RETURNS>
GIObjectInfo    *info
</FUNCTION>
<FUNCTION>
<NAME>g_object_info_get_interface</NAME>
<RETURNS>GIInterfaceInfo *</RETURNS>
GIObjectInfo    *info,gint            n
</FUNCTION>
<FUNCTION>
<NAME>g_object_info_get_n_fields</NAME>
<RETURNS>gint                   </RETURNS>
GIObjectInfo    *info
</FUNCTION>
<FUNCTION>
<NAME>g_object_info_get_field</NAME>
<RETURNS>GIFieldInfo *</RETURNS>
GIObjectInfo    *info,gint            n
</FUNCTION>
<FUNCTION>
<NAME>g_object_info_get_n_properties</NAME>
<RETURNS>gint                   </RETURNS>
GIObjectInfo    *info
</FUNCTION>
<FUNCTION>
<NAME>g_object_info_get_property</NAME>
<RETURNS>GIPropertyInfo *</RETURNS>
GIObjectInfo    *info,gint            n
</FUNCTION>
<FUNCTION>
<NAME>g_object_info_get_n_methods</NAME>
<RETURNS>gint                   </RETURNS>
GIObjectInfo    *info
</FUNCTION>
<FUNCTION>
<NAME>g_object_info_get_method</NAME>
<RETURNS>GIFunctionInfo *</RETURNS>
GIObjectInfo    *info,gint            n
</FUNCTION>
<FUNCTION>
<NAME>g_object_info_find_method</NAME>
<RETURNS>GIFunctionInfo *</RETURNS>
GIObjectInfo *info,const gchar *name
</FUNCTION>
<FUNCTION>
<NAME>g_object_info_get_n_signals</NAME>
<RETURNS>gint                   </RETURNS>
GIObjectInfo    *info
</FUNCTION>
<FUNCTION>
<NAME>g_object_info_get_signal</NAME>
<RETURNS>GISignalInfo *</RETURNS>
GIObjectInfo    *info,gint            n
</FUNCTION>
<FUNCTION>
<NAME>g_object_info_get_n_vfuncs</NAME>
<RETURNS>gint                   </RETURNS>
GIObjectInfo    *info
</FUNCTION>
<FUNCTION>
<NAME>g_object_info_get_vfunc</NAME>
<RETURNS>GIVFuncInfo *</RETURNS>
GIObjectInfo    *info,gint            n
</FUNCTION>
<FUNCTION>
<NAME>g_object_info_get_n_constants</NAME>
<RETURNS>gint                   </RETURNS>
GIObjectInfo    *info
</FUNCTION>
<FUNCTION>
<NAME>g_object_info_get_constant</NAME>
<RETURNS>GIConstantInfo *</RETURNS>
GIObjectInfo    *info,gint            n
</FUNCTION>
<FUNCTION>
<NAME>g_object_info_get_class_struct</NAME>
<RETURNS>GIStructInfo *</RETURNS>
GIObjectInfo    *info
</FUNCTION>
<FUNCTION>
<NAME>g_interface_info_get_n_prerequisites</NAME>
<RETURNS>gint                   </RETURNS>
GIInterfaceInfo *info
</FUNCTION>
<FUNCTION>
<NAME>g_interface_info_get_prerequisite</NAME>
<RETURNS>GIBaseInfo *</RETURNS>
GIInterfaceInfo *info,gint        n
</FUNCTION>
<FUNCTION>
<NAME>g_interface_info_get_n_properties</NAME>
<RETURNS>gint                   </RETURNS>
GIInterfaceInfo *info
</FUNCTION>
<FUNCTION>
<NAME>g_interface_info_get_property</NAME>
<RETURNS>GIPropertyInfo *</RETURNS>
GIInterfaceInfo *info,gint        n
</FUNCTION>
<FUNCTION>
<NAME>g_interface_info_get_n_methods</NAME>
<RETURNS>gint                   </RETURNS>
GIInterfaceInfo *info
</FUNCTION>
<FUNCTION>
<NAME>g_interface_info_get_method</NAME>
<RETURNS>GIFunctionInfo *</RETURNS>
GIInterfaceInfo *info,gint        n
</FUNCTION>
<FUNCTION>
<NAME>g_interface_info_find_method</NAME>
<RETURNS>GIFunctionInfo *</RETURNS>
GIInterfaceInfo *info,const gchar *name
</FUNCTION>
<FUNCTION>
<NAME>g_interface_info_get_n_signals</NAME>
<RETURNS>gint                   </RETURNS>
GIInterfaceInfo *info
</FUNCTION>
<FUNCTION>
<NAME>g_interface_info_get_signal</NAME>
<RETURNS>GISignalInfo *</RETURNS>
GIInterfaceInfo *info,gint        n
</FUNCTION>
<FUNCTION>
<NAME>g_interface_info_get_n_vfuncs</NAME>
<RETURNS>gint                   </RETURNS>
GIInterfaceInfo *info
</FUNCTION>
<FUNCTION>
<NAME>g_interface_info_get_vfunc</NAME>
<RETURNS>GIVFuncInfo *</RETURNS>
GIInterfaceInfo *info,gint        n
</FUNCTION>
<FUNCTION>
<NAME>g_interface_info_get_n_constants</NAME>
<RETURNS>gint                   </RETURNS>
GIInterfaceInfo *info
</FUNCTION>
<FUNCTION>
<NAME>g_interface_info_get_constant</NAME>
<RETURNS>GIConstantInfo *</RETURNS>
GIInterfaceInfo *info,gint        n
</FUNCTION>
<FUNCTION>
<NAME>g_property_info_get_flags</NAME>
<RETURNS>GParamFlags             </RETURNS>
GIPropertyInfo         *info
</FUNCTION>
<FUNCTION>
<NAME>g_property_info_get_type</NAME>
<RETURNS>GITypeInfo *</RETURNS>
GIPropertyInfo         *info
</FUNCTION>
<FUNCTION>
<NAME>g_signal_info_get_flags</NAME>
<RETURNS>GSignalFlags            </RETURNS>
GISignalInfo           *info
</FUNCTION>
<FUNCTION>
<NAME>g_signal_info_get_class_closure</NAME>
<RETURNS>GIVFuncInfo *</RETURNS>
GISignalInfo           *info
</FUNCTION>
<FUNCTION>
<NAME>g_signal_info_true_stops_emit</NAME>
<RETURNS>gboolean                </RETURNS>
GISignalInfo           *info
</FUNCTION>
<ENUM>
<NAME>GIVFuncInfoFlags</NAME>
typedef enum
{
  GI_VFUNC_MUST_CHAIN_UP     = 1 << 0,
  GI_VFUNC_MUST_OVERRIDE     = 1 << 1,
  GI_VFUNC_MUST_NOT_OVERRIDE = 1 << 2
} GIVFuncInfoFlags;
</ENUM>
<FUNCTION>
<NAME>g_vfunc_info_get_flags</NAME>
<RETURNS>GIVFuncInfoFlags        </RETURNS>
GIVFuncInfo            *info
</FUNCTION>
<FUNCTION>
<NAME>g_vfunc_info_get_offset</NAME>
<RETURNS>gint                    </RETURNS>
GIVFuncInfo            *info
</FUNCTION>
<FUNCTION>
<NAME>g_vfunc_info_get_signal</NAME>
<RETURNS>GISignalInfo *</RETURNS>
GIVFuncInfo            *info
</FUNCTION>
<FUNCTION>
<NAME>g_constant_info_get_type</NAME>
<RETURNS>GITypeInfo *</RETURNS>
GIConstantInfo         *info
</FUNCTION>
<FUNCTION>
<NAME>g_constant_info_get_value</NAME>
<RETURNS>gint                    </RETURNS>
GIConstantInfo         *info,GArgument             *value
</FUNCTION>
<USER_FUNCTION>
<NAME>GIFFIClosureCallback</NAME>
<RETURNS>void </RETURNS>
ffi_cif *,
                                      void *,
                                      void **,
                                      void *
</USER_FUNCTION>
<FUNCTION>
<NAME>g_ir_ffi_get_ffi_type</NAME>
<RETURNS>ffi_type *</RETURNS>
GITypeTag             tag
</FUNCTION>
<FUNCTION>
<NAME>g_callable_info_get_ffi_arg_types</NAME>
<RETURNS>ffi_type **</RETURNS>
GICallableInfo       *callable_info
</FUNCTION>
<FUNCTION>
<NAME>g_callable_info_get_ffi_return_type</NAME>
<RETURNS>ffi_type *</RETURNS>
GICallableInfo       *callable_info
</FUNCTION>
<FUNCTION>
<NAME>g_callable_info_prepare_closure</NAME>
<RETURNS>ffi_closure *</RETURNS>
GICallableInfo       *callable_info,ffi_cif              *cif,GIFFIClosureCallback  callback,gpointer              user_data
</FUNCTION>
<FUNCTION>
<NAME>g_callable_info_free_closure</NAME>
<RETURNS>void          </RETURNS>
GICallableInfo       *callable_info,ffi_closure          *closure
</FUNCTION>
<STRUCT>
<NAME>GIrModule</NAME>
</STRUCT>
<STRUCT>
<NAME>GIrModule</NAME>
struct _GIrModule
{ 
  gchar *name;
  gchar *version;
  gchar *shared_library;
  GList *dependencies;
  GList *entries;

  /* All modules that are included directly or indirectly */
  GList *include_modules;

  /* Aliases defined in the module or in included modules */
  GHashTable *aliases;

  /* Structures with the 'disguised' flag (typedef struct _X *X)
  * in the module or in included modules */
  GHashTable *disguised_structures;
};
</STRUCT>
<FUNCTION>
<NAME>g_ir_module_new</NAME>
<RETURNS>GIrModule *</RETURNS>
const gchar *name,const gchar *nsversion,const gchar *module_filename
</FUNCTION>
<FUNCTION>
<NAME>g_ir_module_free</NAME>
<RETURNS>void       </RETURNS>
GIrModule  *module
</FUNCTION>
<FUNCTION>
<NAME>g_ir_module_add_include_module</NAME>
<RETURNS>void       </RETURNS>
GIrModule  *module,GIrModule  *include_module
</FUNCTION>
<FUNCTION>
<NAME>g_ir_module_build_typelib</NAME>
<RETURNS>GTypelib *</RETURNS>
GIrModule  *module,GList       *modules
</FUNCTION>
<STRUCT>
<NAME>GIrNode</NAME>
</STRUCT>
<STRUCT>
<NAME>GIrNodeFunction</NAME>
</STRUCT>
<STRUCT>
<NAME>GIrNodeParam</NAME>
</STRUCT>
<STRUCT>
<NAME>GIrNodeType</NAME>
</STRUCT>
<STRUCT>
<NAME>GIrNodeInterface</NAME>
</STRUCT>
<STRUCT>
<NAME>GIrNodeSignal</NAME>
</STRUCT>
<STRUCT>
<NAME>GIrNodeProperty</NAME>
</STRUCT>
<STRUCT>
<NAME>GIrNodeVFunc</NAME>
</STRUCT>
<STRUCT>
<NAME>GIrNodeField</NAME>
</STRUCT>
<STRUCT>
<NAME>GIrNodeValue</NAME>
</STRUCT>
<STRUCT>
<NAME>GIrNodeEnum</NAME>
</STRUCT>
<STRUCT>
<NAME>GIrNodeBoxed</NAME>
</STRUCT>
<STRUCT>
<NAME>GIrNodeStruct</NAME>
</STRUCT>
<STRUCT>
<NAME>GIrNodeConstant</NAME>
</STRUCT>
<STRUCT>
<NAME>GIrNodeErrorDomain</NAME>
</STRUCT>
<STRUCT>
<NAME>GIrNodeXRef</NAME>
</STRUCT>
<STRUCT>
<NAME>GIrNodeUnion</NAME>
</STRUCT>
<ENUM>
<NAME>GIrNodeTypeId</NAME>
typedef enum 
{
  G_IR_NODE_INVALID      =  0,
  G_IR_NODE_FUNCTION     =  1,
  G_IR_NODE_CALLBACK     =  2,
  G_IR_NODE_STRUCT       =  3,
  G_IR_NODE_BOXED        =  4,
  G_IR_NODE_ENUM         =  5,
  G_IR_NODE_FLAGS        =  6, 
  G_IR_NODE_OBJECT       =  7,
  G_IR_NODE_INTERFACE    =  8,
  G_IR_NODE_CONSTANT     =  9,
  G_IR_NODE_ERROR_DOMAIN = 10,
  G_IR_NODE_UNION        = 11,
  G_IR_NODE_PARAM        = 12,
  G_IR_NODE_TYPE         = 13,
  G_IR_NODE_PROPERTY     = 14,
  G_IR_NODE_SIGNAL       = 15,
  G_IR_NODE_VALUE        = 16,
  G_IR_NODE_VFUNC        = 17,
  G_IR_NODE_FIELD        = 18,
  G_IR_NODE_XREF         = 19
} GIrNodeTypeId;
</ENUM>
<STRUCT>
<NAME>GIrNode</NAME>
struct _GIrNode
{
  GIrNodeTypeId type;
  gchar *name;
};
</STRUCT>
<STRUCT>
<NAME>GIrNodeXRef</NAME>
struct _GIrNodeXRef
{
  GIrNode node;

  gchar *namespace;
};
</STRUCT>
<STRUCT>
<NAME>GIrNodeFunction</NAME>
struct _GIrNodeFunction
{
  GIrNode node;

  gboolean deprecated;
  gboolean is_varargs; /* Not in typelib yet */ 

  gboolean is_method;
  gboolean is_setter;
  gboolean is_getter;
  gboolean is_constructor;
  gboolean wraps_vfunc;
  gboolean throws;

  gchar *symbol;

  GIrNodeParam *result;
  GList *parameters;
};
</STRUCT>
<STRUCT>
<NAME>GIrNodeType</NAME>
struct _GIrNodeType 
{
  GIrNode node;

  gboolean is_pointer;
  gboolean is_basic;
  gboolean is_array;
  gboolean is_glist;
  gboolean is_gslist;
  gboolean is_ghashtable;
  gboolean is_interface;
  gboolean is_error;
  gint tag;

  gchar *unparsed;

  gboolean zero_terminated;
  gboolean has_length;
  gint length;
  gboolean has_size;
  gint size;
  
  GIrNodeType *parameter_type1;
  GIrNodeType *parameter_type2;  

  gchar *interface;
  gchar **errors;
};
</STRUCT>
<STRUCT>
<NAME>GIrNodeParam</NAME>
struct _GIrNodeParam 
{
  GIrNode node;

  gboolean in;
  gboolean out;
  gboolean dipper;
  gboolean optional;
  gboolean retval;
  gboolean allow_none;
  gboolean transfer;
  gboolean shallow_transfer;
  GIScopeType scope;
  
  gint8 closure;
  gint8 destroy;
  
  GIrNodeType *type;
};
</STRUCT>
<STRUCT>
<NAME>GIrNodeProperty</NAME>
struct _GIrNodeProperty
{
  GIrNode node;

  gboolean deprecated;

  gchar *name;
  gboolean readable;
  gboolean writable;
  gboolean construct;
  gboolean construct_only;
  
  GIrNodeType *type;
};
</STRUCT>
<STRUCT>
<NAME>GIrNodeSignal</NAME>
struct _GIrNodeSignal 
{
  GIrNode node;

  gboolean deprecated;

  gboolean run_first;
  gboolean run_last;
  gboolean run_cleanup;
  gboolean no_recurse;
  gboolean detailed;
  gboolean action;
  gboolean no_hooks;
  
  gboolean has_class_closure;
  gboolean true_stops_emit;
  
  gint class_closure;
  
  GList *parameters;
  GIrNodeParam *result;    
};
</STRUCT>
<STRUCT>
<NAME>GIrNodeVFunc</NAME>
struct _GIrNodeVFunc 
{
  GIrNode node;

  gboolean is_varargs; /* Not in typelib yet */ 
  gboolean must_chain_up;
  gboolean must_be_implemented;
  gboolean must_not_be_implemented;
  gboolean is_class_closure;
  
  GList *parameters;
  GIrNodeParam *result;      

  gint offset;
};
</STRUCT>
<STRUCT>
<NAME>GIrNodeField</NAME>
struct _GIrNodeField
{
  GIrNode node;

  gboolean readable;
  gboolean writable;
  gint bits;
  gint offset;
  
  GIrNodeType *type;
};
</STRUCT>
<STRUCT>
<NAME>GIrNodeInterface</NAME>
struct _GIrNodeInterface
{
  GIrNode node;

  gboolean abstract;
  gboolean deprecated;

  gchar *gtype_name;
  gchar *gtype_init;

  gchar *parent;
  gchar *class_struct; /* Only applies to classes */
  
  GList *interfaces;
  GList *prerequisites;

  gint alignment;
  gint size;
  
  GList *members;
};
</STRUCT>
<STRUCT>
<NAME>GIrNodeValue</NAME>
struct _GIrNodeValue
{
  GIrNode node;

  gboolean deprecated;

  guint32 value;
};
</STRUCT>
<STRUCT>
<NAME>GIrNodeConstant</NAME>
struct _GIrNodeConstant
{
  GIrNode node;

  gboolean deprecated;

  GIrNodeType *type;
  
  gchar *value;
};
</STRUCT>
<STRUCT>
<NAME>GIrNodeEnum</NAME>
struct _GIrNodeEnum
{
  GIrNode node;

  gboolean deprecated;
  gint storage_type;

  gchar *gtype_name;
  gchar *gtype_init;

  GList *values;
};
</STRUCT>
<STRUCT>
<NAME>GIrNodeBoxed</NAME>
struct _GIrNodeBoxed
{ 
  GIrNode node;

  gboolean deprecated;

  gchar *gtype_name;
  gchar *gtype_init;

  gint alignment;
  gint size;
  
  GList *members;
};
</STRUCT>
<STRUCT>
<NAME>GIrNodeStruct</NAME>
struct _GIrNodeStruct
{
  GIrNode node;

  gboolean deprecated;
  gboolean disguised;
  gboolean is_gclass_struct;

  gchar *gtype_name;
  gchar *gtype_init;

  gint alignment;
  gint size;
  
  GList *members;
};
</STRUCT>
<STRUCT>
<NAME>GIrNodeUnion</NAME>
struct _GIrNodeUnion
{
  GIrNode node;

  gboolean deprecated;
  
  GList *members;
  GList *discriminators;

  gchar *gtype_name;
  gchar *gtype_init;

  gint alignment;
  gint size;

  gint discriminator_offset;
  GIrNodeType *discriminator_type;
};
</STRUCT>
<STRUCT>
<NAME>GIrNodeErrorDomain</NAME>
struct _GIrNodeErrorDomain
{
  GIrNode node;

  gboolean deprecated;
  
  gchar *name;
  gchar *getquark;
  gchar *codes;
};
</STRUCT>
<FUNCTION>
<NAME>g_ir_node_new</NAME>
<RETURNS>GIrNode *</RETURNS>
GIrNodeTypeId type
</FUNCTION>
<FUNCTION>
<NAME>g_ir_node_free</NAME>
<RETURNS>void      </RETURNS>
GIrNode    *node
</FUNCTION>
<FUNCTION>
<NAME>g_ir_node_get_size</NAME>
<RETURNS>guint32   </RETURNS>
GIrNode    *node
</FUNCTION>
<FUNCTION>
<NAME>g_ir_node_get_full_size</NAME>
<RETURNS>guint32   </RETURNS>
GIrNode    *node
</FUNCTION>
<FUNCTION>
<NAME>g_ir_node_build_typelib</NAME>
<RETURNS>void      </RETURNS>
GIrNode    *node,GIrModule  *module,GList       *modules,GHashTable  *strings,GHashTable  *types,guchar      *data,guint32     *offset,guint32     *offset2
</FUNCTION>
<FUNCTION>
<NAME>g_ir_node_cmp</NAME>
<RETURNS>int       </RETURNS>
GIrNode    *node,GIrNode    *other
</FUNCTION>
<FUNCTION>
<NAME>g_ir_node_can_have_member</NAME>
<RETURNS>gboolean  </RETURNS>
GIrNode    *node
</FUNCTION>
<FUNCTION>
<NAME>g_ir_node_add_member</NAME>
<RETURNS>void      </RETURNS>
GIrNode         *node,GIrNodeFunction *member
</FUNCTION>
<FUNCTION>
<NAME>write_string</NAME>
<RETURNS>guint32   </RETURNS>
const gchar *str,GHashTable  *strings,guchar      *data,guint32     *offset
</FUNCTION>
<FUNCTION>
<NAME>g_ir_node_param_direction_string</NAME>
<RETURNS>const gchar *</RETURNS>
GIrNodeParam * node
</FUNCTION>
<FUNCTION>
<NAME>g_ir_node_type_to_string</NAME>
<RETURNS>const gchar *</RETURNS>
GIrNodeTypeId type
</FUNCTION>
<FUNCTION>
<NAME>g_ir_find_node</NAME>
<RETURNS>gboolean </RETURNS>
GIrModule  *module,GList      *modules,const char *name,GIrNode   **node_out,GIrModule **module_out
</FUNCTION>
<FUNCTION>
<NAME>g_ir_node_compute_offsets</NAME>
<RETURNS>void </RETURNS>
GIrNode   *node,GIrModule *module,GList     *modules
</FUNCTION>
<STRUCT>
<NAME>GIrParser</NAME>
</STRUCT>
<FUNCTION>
<NAME>g_ir_parser_new</NAME>
<RETURNS>GIrParser *</RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>g_ir_parser_free</NAME>
<RETURNS>void       </RETURNS>
GIrParser          *parser
</FUNCTION>
<FUNCTION>
<NAME>g_ir_parser_set_includes</NAME>
<RETURNS>void       </RETURNS>
GIrParser          *parser,const gchar *const *includes
</FUNCTION>
<FUNCTION>
<NAME>g_ir_parser_parse_string</NAME>
<RETURNS>GList *</RETURNS>
GIrParser    *parser,const gchar  *namespace,const gchar  *buffer,gssize        length,GError      **error
</FUNCTION>
<FUNCTION>
<NAME>g_ir_parser_parse_file</NAME>
<RETURNS>GList *</RETURNS>
GIrParser    *parser,const gchar  *filename,GError      **error
</FUNCTION>
<FUNCTION>
<NAME>g_idl_writer_save_file</NAME>
<RETURNS>void </RETURNS>
GIdlModule *module, const gchar *filename
</FUNCTION>
<MACRO>
<NAME>G_IR_MAGIC</NAME>
#define G_IR_MAGIC "GOBJ\nMETADATA\r\n\032"
</MACRO>
<MACRO>
<NAME>BLOB_IS_REGISTERED_TYPE</NAME>
#define BLOB_IS_REGISTERED_TYPE(blob)               \
        ((blob)->blob_type == BLOB_TYPE_STRUCT ||   \
         (blob)->blob_type == BLOB_TYPE_UNION  ||   \
         (blob)->blob_type == BLOB_TYPE_ENUM   ||   \
         (blob)->blob_type == BLOB_TYPE_OBJECT ||   \
         (blob)->blob_type == BLOB_TYPE_INTERFACE)
</MACRO>
<STRUCT>
<NAME>GTypelib</NAME>
struct _GTypelib {
  guchar *data;
  gsize len;
  gboolean owns_memory;
  GMappedFile *mfile;
  GList *modules;
};
</STRUCT>
<FUNCTION>
<NAME>g_typelib_get_dir_entry</NAME>
<RETURNS>DirEntry *</RETURNS>
GTypelib *typelib,guint16   index
</FUNCTION>
<FUNCTION>
<NAME>g_typelib_check_sanity</NAME>
<RETURNS>void      </RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>g_typelib_get_string</NAME>
#define   g_typelib_get_string(typelib,offset) ((const gchar*)&(typelib->data)[(offset)])
</MACRO>
<ENUM>
<NAME>GTypelibError</NAME>
typedef enum
{
  G_TYPELIB_ERROR_INVALID,
  G_TYPELIB_ERROR_INVALID_HEADER,
  G_TYPELIB_ERROR_INVALID_DIRECTORY,
  G_TYPELIB_ERROR_INVALID_ENTRY,
  G_TYPELIB_ERROR_INVALID_BLOB
} GTypelibError;
</ENUM>
<MACRO>
<NAME>G_TYPELIB_ERROR</NAME>
#define G_TYPELIB_ERROR (g_typelib_error_quark ())
</MACRO>
<FUNCTION>
<NAME>g_typelib_error_quark</NAME>
<RETURNS>GQuark </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>g_typelib_validate</NAME>
<RETURNS>gboolean </RETURNS>
GTypelib  *typelib,GError    **error
</FUNCTION>
